// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: songs.sql

package db

import (
	"context"

	"github.com/google/uuid"
)

const countSongVerses = `-- name: CountSongVerses :one
SELECT 
  COUNT(*) AS verse_count
FROM (
  SELECT 
    unnest(string_to_array("text", E'\n')) AS verse
  FROM songs
  WHERE "group" = $1 AND "name" = $2
) AS verses
WHERE verse <> ''
`

type CountSongVersesParams struct {
	Group string `json:"group"`
	Name  string `json:"name"`
}

func (q *Queries) CountSongVerses(ctx context.Context, arg CountSongVersesParams) (int64, error) {
	row := q.db.QueryRow(ctx, countSongVerses, arg.Group, arg.Name)
	var verse_count int64
	err := row.Scan(&verse_count)
	return verse_count, err
}

const createSong = `-- name: CreateSong :one
INSERT INTO songs (
"group",
"name",
"release_date",
"text",
"link"
) VALUES (
 $1,$2,$3,$4,$5
) RETURNING id, "group", name, release_date, text, link
`

type CreateSongParams struct {
	Group       string `json:"group"`
	Name        string `json:"name"`
	ReleaseDate string `json:"release_date"`
	Text        string `json:"text"`
	Link        string `json:"link"`
}

func (q *Queries) CreateSong(ctx context.Context, arg CreateSongParams) (Song, error) {
	row := q.db.QueryRow(ctx, createSong,
		arg.Group,
		arg.Name,
		arg.ReleaseDate,
		arg.Text,
		arg.Link,
	)
	var i Song
	err := row.Scan(
		&i.ID,
		&i.Group,
		&i.Name,
		&i.ReleaseDate,
		&i.Text,
		&i.Link,
	)
	return i, err
}

const deleteSong = `-- name: DeleteSong :exec
DELETE FROM songs
WHERE id = $1
`

func (q *Queries) DeleteSong(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteSong, id)
	return err
}

const getSong = `-- name: GetSong :one
SELECT id, "group", name, release_date, text, link FROM songs
WHERE id = $1
`

func (q *Queries) GetSong(ctx context.Context, id uuid.UUID) (Song, error) {
	row := q.db.QueryRow(ctx, getSong, id)
	var i Song
	err := row.Scan(
		&i.ID,
		&i.Group,
		&i.Name,
		&i.ReleaseDate,
		&i.Text,
		&i.Link,
	)
	return i, err
}

const songVerses = `-- name: SongVerses :many
SELECT 
  verses."name",
  verses.verse
FROM (
  SELECT 
    songs."name",
    unnest(string_to_array(songs."text", E'\n')) AS verse
  FROM songs
  WHERE songs."group" = $1 AND songs."name" = $2
) AS verses
WHERE verses.verse <> '' -- Filter out empty lines
LIMIT $3 OFFSET $4
`

type SongVersesParams struct {
	Group  string `json:"group"`
	Name   string `json:"name"`
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
}

type SongVersesRow struct {
	Name  string      `json:"name"`
	Verse interface{} `json:"verse"`
}

func (q *Queries) SongVerses(ctx context.Context, arg SongVersesParams) ([]SongVersesRow, error) {
	rows, err := q.db.Query(ctx, songVerses,
		arg.Group,
		arg.Name,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SongVersesRow
	for rows.Next() {
		var i SongVersesRow
		if err := rows.Scan(&i.Name, &i.Verse); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateSong = `-- name: UpdateSong :one
UPDATE songs
SET
  "group" = COALESCE($1, "group"),
  name = COALESCE($2, name),
  release_date = COALESCE($3, release_date),
  text = COALESCE($4, text),
  link = COALESCE($5, link)
WHERE id = $6
RETURNING id, "group", name, release_date, text, link
`

type UpdateSongParams struct {
	Group       string    `json:"group"`
	Name        string    `json:"name"`
	ReleaseDate string    `json:"release_date"`
	Text        string    `json:"text"`
	Link        string    `json:"link"`
	ID          uuid.UUID `json:"id"`
}

func (q *Queries) UpdateSong(ctx context.Context, arg UpdateSongParams) (Song, error) {
	row := q.db.QueryRow(ctx, updateSong,
		arg.Group,
		arg.Name,
		arg.ReleaseDate,
		arg.Text,
		arg.Link,
		arg.ID,
	)
	var i Song
	err := row.Scan(
		&i.ID,
		&i.Group,
		&i.Name,
		&i.ReleaseDate,
		&i.Text,
		&i.Link,
	)
	return i, err
}
